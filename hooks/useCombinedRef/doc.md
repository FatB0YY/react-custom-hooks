# useCombinedRef

Хук `useCombinedRef` (иногда его называют `useForkRef`) позволяет объединить несколько рефов в один. Часто возникает ситуация, когда вам нужно передать один и тот же DOM-элемент или экземпляр компонента сразу в несколько мест:

Например, один реф используется для работы компонента, а другой — для проброса наружу (`forwarding`).
Или вам нужно объединить внутренний локальный ref с рефом, полученным из пропсов.
Этот хук не «сливает» рефы в один объект, а создаёт `callback`, который при вызове (например, когда React монтирует или размонтирует компонент) обновляет все переданные рефы одним значением.

Это удобно, когда вам нужно одновременно использовать несколько рефов для одного и того же DOM-элемента, например, для внутренней логики компонента и для внешнего доступа через `forwardRef`.

## Разбор работы хука:

В рефе может храниться все что угодно, поэтому значение рефа будет дженерик параметр. Далее сам реф, который передается в `useCombinedRef` может быть:

1. функциональный реф (cb-ref)
2. объектный реф
3. null
4. undefined

Сам хук простой - это обычная функция, завернутая в `useCallback`, в депсах рефы.
И внутри проходимся циклом по каждому рефу, если реф `null | undefined`, ничего не делаем. Если реф функция, вызывается эта функция с переданным параметром (`element`), если же реф является объектом, то обновляем `current`.

На выходе получаем один реф, где под капотом обновляются все нужные рефы.

## Подробнее:

1. **Аргументы хука**

   Функция принимает неограниченное число аргументов refs (с использованием rest-параметров). Это позволяет передать один или несколько рефов, которые нужно обновлять синхронно.

2. **useCallback и мемоизация функции**

   Функция `refCb` создаётся с помощью `useCallback`. Это нужно, чтобы возвращаемый `callback` не изменялся при каждом рендере, а создавался только тогда, когда изменяются сами переданные рефы (то есть их ссылки).

   **Нюанс**: Здесь массив зависимостей для `useCallback` — это `refs`. Поскольку refs передаются как rest-параметры, они создаются заново при каждом вызове родительского компонента, если не мемоизированы. Поэтому для полной стабильности callback стоит передавать стабильные (мемоизированные) рефы.

3. **Логика внутри callback'а (refCb)**

   Для каждого ref из массива refs:

   - Если `ref` равен `null` или `undefined`, он пропускается.
   - Если `ref` — функция, она вызывается с аргументом `element`.
   - Если `ref` — объект (то есть имеет свойство `current`), то выполняется присваивание: `ref.current = element`.

4. **Возврат callback'а**

   Хук возвращает функцию `refCb`, которую можно использовать как ref для элемента. При монтировании/размонтировании компонента React вызывает этот `callback`, передавая в него DOM-элемент (или `null`), а функция обновляет все переданные рефы.

**Что делает хук?**

Он создаёт единую callback-функцию, которая при вызове присваивает переданный ей элемент (или null) каждому из рефов, переданных в хук.

**Объединяет ли он рефы?**

Нет, он не создает новый объединённый ref-объект, а лишь делегирует присваивание одного и того же значения нескольким рефам. Это похоже на "форкинг" (forking) рефов.
