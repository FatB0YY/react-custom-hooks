# useDebounce

Код реализует дебаунсинг (debounce) – технику, при которой вызовы функции «откладываются» до момента, когда поток вызовов прекратится на заданный промежуток времени. Это полезно, например, для оптимизации ввода (при наборе текста, события resize или scroll), чтобы не запускать дорогостоящие операции слишком часто.

Кроме того, реализован специальный хук useEvent, который гарантирует, что создаётся стабильный (одинаковый по ссылке) колбэк, но при этом он всегда использует актуальную версию переданной функции. Это решает проблему «устаревших замыканий».

## Разбор useDebounce

**fn**: функция, которую нужно «обернуть» в дебаунсинг.
**ms**: задержка в миллисекундах, в течение которой функция будет «откладываться».
Дженерик `<Fn extends (...args: any[]) => any>` гарантирует, что fn может быть только функцией с любыми аргументами и возвращать любое значение, но не может быть строкой или числом.

1. Шаг 1. Получение стабильного колбэка через `useEvent`
   **Зачем это нужно?**
   При каждом рендере компонента функция fn может быть создана заново, что приводит к изменению её ссылки. Но если она используется внутри других хуков (например, в useMemo или таймауте), то это может вызвать проблемы (устаревшие замыкания или лишние пересоздания).
   Хук useEvent возвращает стабильную (по ссылке неизменную) функцию, которая всегда вызывает актуальную версию fn. Таким образом, даже если fn изменится, внутри дебаунсинга будет использована её последняя версия.

2. Шаг 2. Создание дебаунсированной функции с помощью `useMemo`
   `useMemo` гарантирует, что функция `debouncedFn` будет создана только при изменении зависимостей (memoizedFn или ms). Это важно, чтобы не пересоздавать обёртку при каждом рендере, что могло бы приводить к потере состояния (например, отмены запланированного таймаута).

   **Передаваемая функция в debounce:**
   Мы создаём анонимную функцию, которая принимает все аргументы (типизированные через `Parameters<Fn>`) и вызывает `memoizedFn` с этими аргументами. Функция `debounce` (описана ниже) создаёт новую функцию, которая будет «откладывать» вызов исходной функции на ms миллисекунд.

3. Шаг 3. Очистка таймаута при размонтировании компонента
   Здесь используется `useEffect` с функцией очистки (cleanup). Функция очистки вызывается либо при размонтировании компонента, либо перед тем, как `debouncedFn` изменится (если зависимость обновится).
   В этой функции вызывается `debouncedFn.cancel()`, что гарантирует, что при уходе компонента не останется активного таймаута, и тем самым предотвращаются потенциальные утечки памяти или неожиданные вызовы функции после размонтирования.

4. Шаг 4. Возврат дебаунсированной функции
   Хук возвращает готовую к использованию функцию, которая оборачивает вызов `fn` с дебаунсингом.

# Функция debounce

Эта функция не является React-хуком, а обычной функцией, реализующей паттерн дебаунсинга.

## Разбор функции debounce

### Параметры функции

- **`fn`**: Функция, которую нужно «обернуть» в дебаунсинг.
- **`ms`**: Задержка в миллисекундах, в течение которой функция будет «откладываться».

Дженерик `<Fn extends (...args: any[]) => any>` гарантирует, что `fn` может быть только функцией с любыми аргументами и возвращать любое значение, но не может быть строкой или числом.

### Локальная переменная `timeoutId`

- Хранит идентификатор таймаута, возвращаемый функцией `setTimeout`.
- Если таймаут активен, переменная содержит число, иначе – `null`.

### Функция `debounced`

1. **Отмена предыдущего таймаута**

   - Если `timeoutId` имеет числовое значение, значит, был запланирован предыдущий вызов.
   - В этом случае вызывается `clearTimeout(timeoutId)`, чтобы отменить его.

2. **Установка нового таймаута**

   - С помощью `setTimeout` создаётся новый вызов функции, который произойдёт через `ms` миллисекунд.

   **Когда таймаут срабатывает:**

   - Переменная `timeoutId` сбрасывается в `null` (что показывает, что таймаут больше не активен).
   - Вызывается исходная функция `fn` с использованием `fn.apply(null, args)`, что передаёт все аргументы, полученные в `debounced`.

3. **Добавление метода `cancel`**

   **Назначение метода:**  
   Позволяет вручную отменить ожидающий таймаут. Это особенно полезно, когда, например, компонент размонтируется, и нам нужно гарантированно отменить отложенный вызов.

   **Как работает:**

   - Проверяется, существует ли активный таймаут (`timeoutId` является числом).
   - Если да, то он очищается через `clearTimeout`.
