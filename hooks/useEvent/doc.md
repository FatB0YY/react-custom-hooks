# useEvent

Зачастую хак с рефами идет в связке с функциями, что нам необходимо не только какое то значение мемоизировать, но и колбек. Поэтому если мы знаем это, то можно создать хук `useEvent`.

## Разбор работы хука:

В первую очередь этот хук принимает функцию, он может принимать любую функцию. То есть дженерик (extends) нужен, чтобы явно указать, что можно передавать функцию, с любыми аргументами и любым возвращаемым значением. Однако если передать строку или примитив, то это будет неправильно.

Далее мы заворачиваем эту функцию в useRef и затем, каждый раз, когда меняется эта функция (ссылка на функцию пересоздается), обновляем значение рефа на более актуальное значение.

Тк мы знаем, что в рефе точно всегда хранится актуальная функция, создается удобная обертка с useCallback, и в депсах находится fnRef, соответственно этот fnRef создастся только один раз, поэтому eventCb тоже всегда будет иметь одну и ту же ссылку.

Parameters и ReturnType используется, чтобы функция имела такую же типизацию как и переданная функция.

И с помощью apply передаем все аргументы в нашу оригинальную функцию.

## Объяснение chatgpt:

### Короткий ответ:

этот хук чаще используют не совсем для «мемоизации» в классическом понимании (т. е. кеширования результата выполнения функции), а для стабилизации (или «фиксации») ссылки на колбэк — при этом сам «живой» код функции может обновляться в зависимости от props/state, но снаружи ссылка остаётся одной и той же. Это помогает избегать лишних перерисовок и проблем со старыми (устаревшими) замыканиями.

Ниже — более подробное объяснение, зачем это нужно и как работает.

### В чём суть проблемы со «старыми» колбэками

В классическом случае, когда мы используем useCallback(fn, [deps]), мы хотим, чтобы ссылка на колбэк не пересоздавалась, пока зависящие от неё данные (deps) не поменялись. Это экономит ресурсы, особенно если этот колбэк передаётся куда-то дальше, например в дочерние компоненты (чтобы не вызывать их перерисовку лишний раз), или если вы используете его в useEffect как dependency.

Однако у такого подхода возникает проблема «устаревшего замыкания» (stale closure), когда внутренняя реализация колбэка может использовать «старые» значения пропсов или стейта, которые были на момент создания функции.

### Пример

Допустим, у нас есть компонент, где мы используем классический useCallback, зависящий только от каких-то специфических переменных:

```ts
function MyComponent({ user }) {
  const handleClick = useCallback(() => {
    console.log(user.name);
  }, [user.id]); // допустим, здесь зависим от user.id

  // ...
}
```

Если вдруг user.name поменяется, но user.id — нет, то колбэк «не заметит» новое имя. Ведь при useCallback вы указали user.id как dependency, и React решит, что «раз user.id не менялся, значит функция не должна пересоздаваться». Так мы и получим «старое значение».

Бывает, что нужно с одной стороны хранить в колбэке самый актуальный код, а с другой — давать наружу стабильную ссылку (т.е. сам объект функции всегда один и тот же, но внутри него используется актуальный fn).

### Как работает useEvent

Исходный код вашего useEvent делает следующее:

### Хранит функцию в ref:

```ts
const fnRef = useRef(fn);

useLayoutEffect(() => {
  fnRef.current = fn;
}, [fn]);
```

После каждого рендера в fnRef.current записывается актуальная версия fn.
При этом сам ref не меняется между рендерами (ведь это одна и та же ссылка fnRef).

### Возвращает колбэк через useCallback:

```ts
const eventCb = useCallback(
  (...args: Parameters<T>): ReturnType<T> => {
    return fnRef.current.apply(null, args);
  },
  [fnRef]
);
```

Сам колбэк, возвращаемый хуком, создаётся один раз (или, точнее, ре-креируется только если поменяется fnRef, а fnRef у нас — это объект ref, он не меняется).
Внутри тела колбэка вызывается fnRef.current, т. е. всегда последняя (актуальная) версия функции fn.
Благодаря этому наружу мы отдаём стабильную ссылку на функцию eventCb, но внутри неё всегда используется самый свежий fn.
Таким образом, useEvent — это «лучшее из двух миров»:

Снаружи у вас одна и та же ссылка (не вызывает лишних перерисовок, удобна как dependency),
Внутри колбэка используется актуальный код (нет проблемы «устаревших» замыканий).

### Зачем это нужно и когда применять

Избавиться от устаревших замыканий (stale closure).
Если ваш код зависит от множества переменных, которые не хочется явно прокидывать в зависимости useCallback, useEvent убережёт от проблем со старыми значениями.

Иметь стабильную (неизменную) ссылку на колбэк.
Нередко это нужно при работе со сторонними библиотеками (например, если вы передаёте callback куда-то во внешнюю либу, которая ожидает, что ссылка не будет меняться, иначе у неё могут сбрасываться внутренние данные).

Избавляться от лишних ререндеров дочерних компонентов.
Если вы передаёте колбэк как пропс детям, и дети зависят от изменения ссылки на функцию, тогда неизменный колбэк = меньше перерисовок.

Однако важно понимать, что внутри такого колбэка нужно аккуратно обращаться со значениями, которые вы берёте из пропсов/стейта. Они не будут «заморожены», а наоборот, всегда будут браться по последним версиям (через fnRef.current). Это иногда меняет поведение компонентов, если вы привыкли к классическому «закрытию» значений в замыкании.

### Итог

Да, это похоже на «мемоизацию», но скорее мемоизируется сама ссылка на колбэк (чтобы она не менялась) и при этом используется актуальная реализация функции (через ref).
Цель — иметь стабильный колбэк, который не будет вызывать проблем ни со старыми данными, ни с постоянным пересозданием ссылки.
В коде применяется паттерн «useRef + useCallback», который можно встретить и как useEvent в разных библиотеках или в будущих (экспериментальных) API React.
Если у вас возникает вопрос «всегда ли это нужно?», то обычно такие вещи полезны в специфических случаях (например, при передаче колбэков глубоко в дерево компонентов или во внешние обработчики). Во многих местах достаточно обычных useCallback или вообще без оного, если колбэк не вызывается частно или не передаётся в дорогостоящие вычислительные контексты.
